# Course Overview

## What Is Spring Data?

### Why Spring Data?
Taking a step back, let's think about how we would access data from Java without Spring Data. Here we have a Java application on the left and a database on the right. Now typically, we would use a data access library to access our data where we create code to do things like query execution or result mapping. If we were working on an SQL database and maybe we'd be writing some JPA or Hibernate code, or if we were working on a document database like MongoDB, we'd be working with the MongoDB driver. What's important to know is that our data access code would be completely different for these two applications. They'd come with different query languages, different libraries for executing those queries, and, in general, share no common interfaces. If we throw Spring Data into the mix, then things work differently. You can think of a Spring Data project as a wrapper around the data access library, always making use of the same common interfaces and abstractions. In other words, if we looked at a project using Spring Data MongoDB from one using Spring Data JPA, the code would be remarkably similar. Aside from that, Spring Data takes the approach of convention over configuration, removing a lot of the data access boilerplate that we would normally have to write ourselves. So what are some of the abstractions that Spring Data makes use of across all of its projects? Well we'll be looking at these in detail throughout the course. But for now, let's do a high‑level overview. The lowest hanging fruit is CRUD, meaning if you create, read, update, or delete some data from a database, then you can use the same CRUDRepository interface to do so. Spring Data also derives queries for us. What this means is that we don't need to write queries ourselves because Spring will generate them based on the names of our methods. This really helps developers who could otherwise be overwhelmed by a query language that they're unfamiliar with. Whilst technically part of Core Spring, we also get transaction management out of the box with Spring Data. The benefit of this is that Spring makes transactions declarative, reducing a lot of boilerplate with the page and sort abstraction available for us to use, which helps us easily traverse through large amounts of data. We also get auditing, allowing us to track who created or changed an entity and when that change happened. And it's important to note that this isn't an exhaustive list, but gives us a glimpse of common problems Spring Data aims to solve. So now we understand a bit more about Spring Data and what it achieves, it's also worth emphasizing its benefits. One core benefit is its consistent programming model. Regardless of the underlying data store, whether it's Cassandra, Neo4J, or MongoDB, you'll still be working with the same familiar Spring Data code for all modules. For example, we'll always be working with the same repository interfaces. This helps keep things familiar for developers. In fact, a lot of the time, developers won't need to the underlying library that a Spring Data module wraps around at all, only working with the Spring Data interfaces. This keeps the learning curve as low as possible for a developer. And when they need to work with a new type of database, Spring Data helps smoothly transition in order for them to get started quickly. Another core benefit is a reduction in boilerplate. Basic CRUD access comes out of the box, and more complex queries are even generated for you. This means developers can focus on writing application code rather than data access plumbing, helping them deliver functional requirements faster. Finally, Spring Data integrates seamlessly with Spring Boot. You're provided with a Spring Boot starter for each Spring Data module. And if you include it in your application, then Spring Boot will takes its convention over configuration approach, setting up a database connection pool, creating entity managers, and more. This leaves you with a minimal amount of configuration to do yourself, again saving developers a bunch of time.

### Spring Data Module Hierarchy
Spring Data is a collection of many projects, and it can be a bit confusing to understand what is what and how they all relate to each other. That's why we'll take a look now at how these projects are structured. The parent project is Spring Data Commons, which all the other modules depend on and make use of. Spring Data Commons provides the interfaces or common programming model that everything else implements. For example, abstractions around CRUD, pagination and sorting, derived queries all come from interfaces in this project. This project is what our focus will be on during this course. Making use of Spring Data Commons, we first have our main modules. In the examples here, we have JPA, JDBC, MongoDB, Cassandra, but there are many more. These main modules are officially backed by Pivotal, the commercial enterprise that owns Spring. This means they're expected to be stable, following the same development and release lifecycle as the rest of the Spring framework. There are also community modules, which also depend on and implement Spring Data Commons. Whilst they aren't officially managed by Pivotal, you can expect the same familiar programming model as the other projects as the majority of code that you'll be working with will be coming from Spring Data Commons.

### What We Will and Won't Cover
Okay, before we get started with our first demo, let's go through what this course will and won't be focusing on. We need to do this simply because the scope of Spring Data is so broad, and we'll only be taking a high-level slice throughout the framework. The main focus will be Spring Data Commons. This parent project is used throughout all of Spring Data, and understanding it is key to being able to use any of the other modules. The core interface we'll be working with is a repository interface, providing an abstraction for writing and querying data. As we can't use Spring Data Commons independently, we'll be using the JPA and MongoDB modules. This, however, is just for demonstrating Commons, and we're not going to touch on the details of either of these implementations. Finally, we're looking at transactions in Spring. Whilst not technically part of Spring Data, Spring transaction management is extremely powerful and directly related to data access. This thin slice through Spring Data will also touch on other concepts. So let's list which of them we'll not be focusing on during the course. The first is Hibernate, JPA, or any other ORM. It's assumed that you already have some knowledge of object relational mapping before starting the course. This only needs to be the basics though as Spring Data Commons does a really good job of abstracting away most of the complexity. We'll also be using Core Spring and Spring Boot during this course, and it's expected you already know the basics of these. Again, if you don't, you'll still be able to get by, but it might be worth covering them in another Pluralsight course. Finally, it's worth mentioning that Spring Data is not for batch processing. Spring Data Batch is a framework independent of Spring Data specifically for that purpose. So if you want to do batch processing, please don't use Spring Data.

### Demo Project Overview
Okay, before we get started, we're going to set up a demo project. Once we've done that, we'll have a Spring Data project ready to go for the next modules where we can start using the framework to query data. The project we'll be working on is a flight arrival system. For this course, we'll have one simple database table that stores a list of flights and their arrival time. We'll then be querying this data using Spring Data. It's also going to be a Spring Boot project. The reason for this is that it takes a convention over configuration approach to Spring applications, meaning that we'll have the minimal amount of setup required to get our project running. To put it simply, Spring Boot makes it easy to get your application off and running as quickly as possible and nowadays should be the default choice when creating a Spring application. We'll be using Spring Data JPA during our POC as we need to pick at least one module in order to use it. But it's important to realize that we'll only be working with the interfaces in Spring Data Commons. Finally, we'll be using a H2 database. H2 is a fast in-memory SQL database that can be embedded into your application. It's mainly used for testing purposes as it doesn't require you to set up an external database. In fact, there's no setup or configuration to be done at all as it automatically starts and stops when you run a test. All the source code for the demo can be found on GitHub. You can clone it from this repository, or you can check the Pluralsight assets directory, and the code will be contained there too. This will be the same for all modules.

### Demo
Okay, in our first demo, we'll be creating a project using Spring Initializr, a simple way of creating a Spring Boot application. We'll then create a Java class, which maps to a database table. And finally, we'll create a small health check test to verify our application boots and that we can write our entity to the database. Okay, to get started with Spring Data, we first need to create our demo project. As this will be a Spring Boot project, the easiest way to do this is via start.spring .io. Essentially, it's an online form, which allows you to select some settings for your new Spring Boot project after which you can then generate it and download it in a ZIP file. For example, you can choose a build tool here, such as Maven or Gradle. We'll be using Maven for this project. You can also choose a language, and, in our case, we'll be sticking with Java. The Spring Boot version is also configurable, but we'll stick with the latest, in this case version 2.1 .9. Okay, for the rest of our project, we need to do some customizations. Let's give our project a group ID, com.pluralsight, an artifact ID, spring-data-overview. Following this, we can scroll down and pick some extra Maven dependencies to be added. Doing it this way is pretty nice as setting up a POM with various starter dependencies and plugins can be a bit cumbersome to do manually. We can first search for Spring Data JPA as it's the Spring Data module we'll be using for this course. We don't need to include Spring Data Commons as it's a transitive dependency of each module. Then, we can add H2, the in-memory database that we'll be using during our tests. And that's about it. All we need to do now is press Generate, and our project will be packaged into a ZIP file and downloaded onto our file system. After this, we can then import the project into our IDE. Okay, so now we've imported our project, let's take a look at its contents. Navigating to our POM file, we can see that it inherits from the spring-boot-starter- parent, providing us with managed dependency versions and plugins. I'm not going to go into too much detail about this as its better covered in a Spring Boot course. Scrolling down, we can see the dependencies that we added, spring-boot-starter-jpa and h2. Spring-boot-starter-test is also added by default. Now let's add one more additional dependency, assertj, as we'll be using it for our test assertions. An alternative, such as Hamcrest or even native assertions would be fine, but I'm choosing AssertJ for personal preference as it comes with some really useful assertions, which we'll make use of throughout the demos. Now that's done, let's navigate to our class file. By default, there's one single class file named after our project annotated with @SpringBootApplication. It comes with a default main method, which will be executed when the application is started. Again, I'm not going to go into the specifics here as this is covered in a Spring Boot-specific course. Navigating to our test directory, we can see this one Spring Boot test named contextLoads. By default, it runs with the SpringRunner, meaning that when we execute it, our Spring Boot application will start up with a close to full context. Let's execute it and look at the logs. We can first see the Spring banner, signifying that our Spring Boot application is starting. We can also see log lines referencing that Spring Data is starting up, for example bootstrapping repositories and, at an even lower level, Hibernate is starting, which is what Spring Data JPA uses behind the scenes. The test has gone green, which means our application and all its dependencies started successfully. Okay, let's start by creating a JPA entity that we'll use during the rest of this course. We'll call it Flight, and it will represent a scheduled flight. This will map directly to a database table. We'll start by giving it an ID field, the database ID, an origin field, representing the airport that a flight starts at, a destination field, representing the airport where it terminates, and a scheduledAt field, representing what time the flight is scheduled to depart. Once we've done this, we can map it with the JPA annotations to make it a managed entity, in other words something that can be loaded and saved into the database using Spring Data JPA. Again, JPA is not the focus of the course, so I won't go into the details of what these annotations do. But essentially, we use our entity to make it recognized as a table, an ID to denote a primary key, which, by default, will be generated for us using a GeneratedValue annotation. Finally, let's generate some getters and setters. We don't need any more JPA annotations because it's intelligent enough to figure out that the rest of the fields map to database columns of the same name. Okay, let's switch to our test and modify it slightly. We're not going to use Spring Data at all here, but we're going to use a Spring JPA EntityManager directly to verify that it's possible to save and read our flight to our H2 database just as a health check to know that everything's set up correctly. Let's start by wiring in our EntityManager and then renaming our test to verifyFlightCanBeSaved. Our EntityManager is set up for us automatically by Spring Boot starter JPA. Once we've done this, we can create an instance of our flight. Let's give it some arbitrary data and then call entityManager.persist to store it in the H2 database. Once we've done that, let's create a query, SELECT FROM Flight, which will read our flight from the database, and then we'll create an assertion that our single flight has been returned, and that it's the same flight as the one we saved. We didn't bother overriding equals here, so it's checking the flights are the same instance, which they are as the EntityManager already has it in memory from when we saved it. We'll also make this a DataJpaTest, which means that only a partial Spring context will be created containing our persistence specific bean, which is H2, our EntityManager, Spring Data repositories, and so on. This, in turn, makes our test execute as quickly as possible as there's no overhead of starting up things that we don't need, such as a web server. If you're wondering about creating our database table, by default, it's created for us based on the JPA annotations. So we don't need to create SQL to do this ourselves. Okay, let's run our test and verify that it passes. It does. This confirms we can save our entity to our database, so we're ready to get started by making use of Spring Data. It's thanks to Spring Boot that this was so simple as the creation and configuration of things, such as our EntityManager, are all handled for us by Spring. This pattern will be the same across all modules of Spring Data.

### Summary
So what have we learned during this module? The first is that Spring Data is not a particular project, but is instead a collection of data access modules. Each of these modules implement Spring Data Commons, which provides the core abstractions for data access with Spring Data. It's a framework that heavily reduces boilerplate, helping you deliver features faster. There's also a gentle learning curve for each Spring Data module, meaning you can get up and running quickly. And the focus of this course will be Spring Data Commons to help us build the foundation we need before working with a specific Spring Data module. In the next module, we'll learn about querying with Spring Data by making use of the Spring Data repository interface.

## Querying Data with the Repository Interface
### Repository Pattern
One of the core patterns that Spring Data makes use of is the repository pattern. In a nutshell, the repository pattern is a persistence ignorant data access abstraction. What this means is that rather than querying a database directly, your application code will communicate with a repository interface instead. Internally, this interface will have an implementation with some data access code, but from your application's point of view, the repository that you work with will be abstract or hide away all of this entirely. Let's explain this with an example. Typically when our application wants to query a database, we do some sort of framework specific for accessing that database. In this example where we have an SQL database, we might make use of JPA to query it. If we introduce a Spring Data repository interface into the equation, it essentially wraps and abstracts our JPA access code for us. Now our code will only query this data store via this repository interface. And although not completely interoperable in all situations, the repository pattern more or less means we're able to completely swap our data store for something else without changing our code. In this case, we've changed to Spring Data Neo4J, which of course implements the same repository interface as all the other modules, keeping the code which uses that repository close to the same.

### Repository Hierarchy
Okay, before we start looking into Spring Data repositories in more detail, we'll first look at a repository hierarchy and how everything relates to each other across multiple modules. The base interface is a repository interface, which all other repository instances inherit from. This is a marker interface with no methods, just argument types for the entity you want to persist and the ID class of the entity. Below this is the CRUDRepository, the one which is most used in Spring Data projects. As the name implies, it comes with generic operations for creating, reading, updating, and deleting entities. That's then inherited by the PagingAndSortingRepository, which again, as the name implies, adds additional generic operations for paging and sorting the data, as well as the original CRUD operations. Whilst the free interfaces live in Spring Data Commons and are used by all modules, the remaining subinterfaces or implementations are module-specific. It's these that will contain all the code specific to the module's database, such as a JPA or MongoDB repository. It's important to note that you're not going to be touching this code yourself and will only be working with the interfaces provided in Spring Data Commons throughout this course.

### Crud Repository
Okay, so let's take a look at the base Repository interface. It doesn't actually have any methods and is just a marker interface. However, it takes two arguments. The first is the type of entity to persist, in other words a Java class, which is mapped to a database table. All repository operations will take place on this entity. The second is the type of the entity's ID class. This might be a long, a EUID, or some other data type. But as it will differ between different data stores, it must be a generic type argument in order for the repository to be completely generic itself. Below the Repository interface, we have the most commonly used CRUDRepository. This provides us with CRUD methods out of the box for our entities. And some of the time this interface might be all our application needs. In our example here, we have a save method for creating or updating entities. We have a method for reading or finding entities by ID, a method for deleting entities, and there are more. Most of the generic CRUD operations you can think of live on this interface, making it very powerful out of the box often with little need to do much else.

### Demo: Crud
Okay, in this demo, we're going to be creating our first CRUDRepository. Once we've done that, we'll use the CRUDRepository to interact with our database table. Okay, let's start by creating a repository interface for our flight entity. We'll create a repository package for it and then call the repository itself FlightRepository. Once we've done that, we make it extend from the CRUDRepository. We'll provide two type arguments, Flight representing the entity that it manages and Long representing the data type of the ID of the entity. Let's then switch back to our test and rename it CrudTests and then delete what's there already as it's no longer needed. We'll use our repository to save and read our flight instead now. Okay, let's create a test named shouldPerformCRUDOperations. We'll then wire in our FlightRepository as a dependency and then start making use of it within our tests. Let's first create a flight entity, populating it with some arbitrary data. Then let's use our repository to save our flight. Remember, all we've done is implement an interface here. Yet now we've got all this data store agnostic capability out of the box. We can see variations of operations for saving, deleting, finding, and more. In our case, let's call save to save our flight instance to a row in the flight table. Once that's done, we can see if it has been saved successfully by reading it back from the database using the repository. We can do this by first calling findAll, which will return all the rows. As we've only saved one flight, there will only be one row so we can assert the list has a size of 1. We can read this first element from the list and assert all of its fields are equal to the fields of the flight that we saved, which they will be as they'll be the same instance of the flight. Next, let's try deleting our flight. Again, this proves how Spring Data JPA is easy to work with as all we need to do is call the preconfigured delete method on our CRUDRepository, passing in the instance of our flight. Afterwards, we can verify that the deletion was successful by doing a count query and asserting that the result is 0. This is because we deleted the only row there is for the table. Thus, it should be empty. Okay, let's run our test and verify that it still passes. It does, which verifies that our repository allows us to interact with the database. Hopefully this is now starting to build a picture of just how powerful Spring Data is as all we've done is implement a single interface, yet we've got all these CRUD operations available to us out of the box.

### Derived Queries
Whilst it might not seem like it at first glance, traditional query creation can involve lots of boilerplate. Let's demonstrate this with an example. The method we have here is called findByName, and it will return our customers in the database with the given name. Although the signature straightforward is making it previous obvious to us what the method should do, we still have to implement the code to execute it. In our case, we're using JPA, so that means creating a native query using the EntityManager, setting the parameters, and then returning the result as a list. And this doesn't even include the code required to convert our results into a list of the customer type. Now if we take a step back and look at this code, it's definitely filled with boilerplate because regardless of whatever read query we'd be doing, our code here would always look more or less the same apart from the query string and parameters. And actually, although the query string is unique, doesn't the method name already look similar to it? Spring Data aims to solve these problems of query boilerplate for derived queries. In a nutshell, a derived query is a query generated by Spring Data for you based on the method signature. So when we declare a method like this one on a Spring Data repository, Spring will be smart enough to generate an implementation of the method for us. Let's step through to see how Spring Data might do this. Spring Data first looks at the method name and maps the word find to the word SELECT. It then sees the word ByName and maps it to WHERE NAME =. Then the value of name is pulled out of the name query parameter. Finally, by looking at the return type, Spring Data knows what to map the result set into. And for this example, that would be it. The specific details of how Spring Data does this is beyond the scope of this course. But an oversimplified explanation is that it will generate an implementation of the interface at runtime based on the method signature, and then this implementation would be what you get when you wire in an instance of the repository. Derived queries are arguably one of Spring Data's most powerful features, and really there's a bunch of different things that can be achieved with them. Let's take a look. We can derive queries that use logical operators, such as and and or, by simply putting the word into the method name. Our queries can also be made case-insensitive by putting terms like IgnoreCase into the method. We can order the results of the query by putting OrderBy, delete elements by column name, in this case the value of name, and even use operators like less than or greater than. If for some reason you think this is overkill and feel that it's fine to query your database with your ORM directly, then first try to think about some of these advantages. In the case of Spring Data derived queries, there's no boilerplate for it at all. All the plumbing that could be done is done for us. Our queries are generated for us based on the method signature, so we don't need to implement them. The queries are also executed for us within the generated code. And finally, the result set is automatically mapped for us into the return type of our methods. The removal of the boilerplate isn't the only advantage though because doing things this way also dramatically reduces the learning curve for developers. This is because the underlying query language is abstracted, letting you work with human readable method names whilst counting on Spring to do the rest for you. So if you are inexperienced with SQL, then derived queries would help you get a quick start. As well as this, we should consider how advantageous interoperability of derived queries are. This is because whilst the examples we've given were of SQL queries being generated, the exact method signatures are convertible into all sorts of different query languages. For example, if you don't know Cassandra in SQL, but you do know Spring Data, then Spring Data Cassandra would be a great way to generate those queries for you. It's only when you run into more complicated, advanced, and database-specific concepts that derived queries won't be enough. But in the basic use cases, they are.

### Demo: Derived Queries
Okay, in this demo, we're going to create some derived queries for our scheduled flights. We're then going to verify that those queries function with a test. Okay, let's start by navigating to our test directory and creating a new test class. We'll call it DerivedQueryTest. Just like our other test, we'll use a SpringRunner and make it a JPA test so only a partial persistent specific Spring context is created during our tests. We'll then wire in our FlightRepository so we can make use of it during the test. This time we'll create a setUp method and call deleteAll during it. This ensures a database is empty at the start of each test. So the state of one test cannot interfere with the state of another by leaving some data behind accidentally. We can call our test shouldFindFlightsFromLondon, and it will be used to query all flights departing from London. Let's start by creating our flight instance, this time with a helper method while we pass in the origin as an argument, London, and the rest of the fields are populated with some defaults. We'll create two flights from London and one flight from New York and then save all three of them to the database using the repository. Okay, what we need to do now is query all the flights from London, which we can't do yet as we've yet to create our repository method to perform the query. Let's assign a list of flights to a call to find by origin the method we're going to create, passing in London as an argument. Then, let's assert that we've received two flights back as only two are to London, and then let's assert that they are equal to flight1 and flight2, not flight3, which was to New York. Okay, thanks to the beauty of derived queries, we don't actually need to implement our methods. We only need to declare it in our interface. Nicely, our IDE can do this for us. Behind the scenes, this method will map to a SELECT * FROM flight WHERE origin = parameter, but only because we're using the JPA version of Spring Data. That's the beauty of the repository pattern as this method would remain the same across multiple Spring Data modules. Whereas a derived query would change based on what's needed for the particular data store being used. Great, let's switch back to our test and run it to confirm that it passes. It does, meaning our derived query has worked successfully. So now we've done a simple example, we're going to create a few more tests trying out some different types of derived queries. We'll start by creating a test called shouldFindFlightsFromLondonToParis. This time we'll give our method two arguments, an origin and a destination, and then we'll generate it. Once this is done, we can create a couple more flights. So we have one from London to Paris, one from London to New York, and one from Madrid to Paris. We'll create a query method called findByOriginAndDestination, passing in London and Paris, and then generate it using our IDE. Behind the scenes, this will become a SELECT * FROM flight WHERE origin = parameter 1 AND destination = parameter 2. Finally, we can assert that our query returns only one flight, the one from London to Paris, in order to verify it works. We can then save the flight so the start of the test, run the test, wait for a second or so, and be pleased to see that the test has gone green proving we've successfully implemented yet another derived query. And now we've done an AND query, we can also try out an OR query. We'll create a test called shouldFindFlightsFromLondonOrMadrid, creating a flight from London to New York, Tokyo to New York, and Madrid to New York too. We'll then save these to the database and then generate our derived query named findByOriginIn, providing an array or arguments. This one's interesting as behind the scenes we can in query where Spring Data is intelligent enough to infer that the array is all of the values to passed into the IN clause. The generated query would be something like SELECT * FROM flight WHERE origin IN values. Finally, let's create our assertion. We expect two elements here as the first flight is from London, and the last flight is from Madrid. On running our test, we can wait and then see that it's gone green, proving again that our query works successfully. Okay, let's create one final test where we query for flights, but make our search case-insensitive. This is something that's likely to come up a lot in a real system, for example if we're dependent on user input. We'll create a flight from London all in uppercase, save the flight, and then, to begin with, use our existing findyByOrigin query. Then we can assert a flight is returned. If we run our test, it will, of course, fail as every flight is returned instead of one. If we switch back to our test method and create a new method called findByOriginIgnoreCase, it should work. Behind the scenes, a query will look something like SELECT * FROM flight WHERE upper origin = upper parameter. Okay, now that's done, let's run our test and see if it now passes. It does. And that covers it for this demo. Whilst we've only hit the tip of the iceberg in terms of what Spring Data is capable of in terms of derived queries, this should hopefully lay a solid foundation for us to start to work with them in the future.

### Paging and Sorting
Another generic problem that Spring Data aims to solve is the paging and sorting of data. Imagine our Java application wanted to read all of the orders from an order table. If we tried a naïve SELECT * FROM orders query, it would work, but would also result in the entire orders table being loaded into memory. If the number of orders was in the order of millions, then this could result in our app running out of memory and crashing, not great. This is why we introduce pagination and sorting into the equation. Instead of querying all the resulting rows, we would only query a slice or a page of them, fixing the memory problem. If we were using SQL, this would mean providing key words like LIMIT, OFFSET, and possibly ORDER BY into the query, introducing this constraint. What's important to realize though is that this is actually an abstract problem. Whatever the database, we're always going to be querying data, and we're always going to need to make sure that the data we return doesn't result in an out of memory error. So pagination will be required wherever we use a graph, document, relational, columnar, or any other type of database. Okay, so let's take a look at paging and sorting in Spring Data. Here is our findyByName derived query from earlier, only it now has two extra arguments, Pageable and Sort. The first thing to note is that when using the page and sort arguments, the query is derived as usual. So with or without these arguments, the same core findByName query is generated. The pageable argument is pretty simple to create. We can build a page request and implementation of Pageable, passing in the page index and size of a page. When our query is generated, adding this parameter will add an offset and LIMIT keyword to it. The sort argument is also simple. In this example, we can create a sort by a column name, in this case date of birth. This will add an order by to the query. And by default, we will get ascending order. As well as using page and sort directly in derived queries, you can also make use of the PagingAndSortingRepository. This is a subclass of the CRUDRepository, overloading the findAll method in the T times. The first method overloads with the sort argument, and the second overloads with the pageable argument. It really is up to you when you make use of this repository or whether you just add page and sort arguments directly to your derived queries. As a rule of thumb though, less code is always better. So I'd recommend defaulting to use of the PagingAndSortingRepository and then creating additional methods on top of it when required.

### Demo: Paging and Sorting
In this demo, we'll be working with the PagingAndSortingRepository to perform paginated queries against our scheduled flights table. We'll try different types of page and sort instances along the way and then finally enrich our derived queries with paging and sorting. To get started, let's navigate to our FlightRepository, this time changing it so it inherits from PagingAndSortingRepository instead of CRUDRepository. If we step into the PagingAndSortingRepository, we can see that it's a subclass of the CRUDRepository, so we don't lose out on any of our existing functionality while gaining two new useful methods. These are a findAll method with a sort argument, letting us sort our results, and a findAll method with a pageable argument, letting us paginate our results. Okay, let's create a new test called PagingAndSortingTests. We'll run it with the SpringRunner and annotate it with DataJpaTest again. Then we'll wire in our FlightRepository after which we'll create a setUp method, which deletes and resets the database between each test. For our first test, we'll keep it simple, calling it shouldSortFlightsByDestination. We'll create a flight which arrives at Madrid, create a helper method in the process so it sets some defaults for the rest of the fields. Then we'll create two more flights, one to London and one to Paris, and then save them both to the database. Okay, now we can create our first sort query. We can call findAll, but this time call Sort.by destination. If it's not obvious, this will mean that the results to findAll will be sorted by the field named destination in ascending order by default. Let's complete our test with an assertion. We'll check that we got all three flights and then iterate through them checking that the order was London, Madrid, and then Paris. Then let's run our test. Great. It's gone green, verifying our query worked as expected, and we organized our flights into ascending order. Now let's try a more complicated sort query where we sort by two separate fields with the first field taking precedence. We'll call it shouldSortFlightsByScheduledAndThenName. We'll start by creating a flight to Paris, this time creating an extra helper method that allows us to provide a schedule time. We'll then create an additional two flights. So we have one flight to Paris now, one flight to Paris in 2 hours, and one flight to Paris an hour ago. Then, let's create two flights to London, one in an hour's time and one now. What we can do now is create a sort query similar to before, only this time we'll sort it by destination. And if the destination fields match, then it will then be sorted by scheduledAt. Spring Data is intelligent enough to know how to create a query that sorts by a local date/time. Finally, let's create our assertions. We'll check that we have all five flights and then that they return in the correct order. Our flight to London should be first, and then the one with the latest schedule time should be last. Then we should receive our three flights to Paris, again ordered by schedule time ascending. Okay, let's run our test and see if it all goes green. It does, verifying our more advanced sort query works perfectly. Now we've experimented with sorting, let's try out some paging. We'll create a test called shouldPageResults, and in it we'll say 50 flights in a for loop. To keep things simple when asserting, we'll give each flight a destination which matches the valueOf i. After this, we can query a page or a slice of the total results using findAll and passing in a page request. We can do PageRequest., passing in 2 to request that we're on the second page and 5 to denote that each page has a length of 5. Rather than the response being a list again, in this case a response is a page abstraction. We can assert that it's working as we expect by verifying some of its fields. We'd expect a total of 50 elements with 5 elements on each page and a page total of 10, which is 50 elements divided by 5. We can then assert that the page-content returns the correct elements. We'd expect page 0 to contain destinations not to 4, page 1 to contain destinations 5 to 9, and, in our case, we'd expect page 2 to contain a 10 to 14 of element. AssertJ makes this easy to check by using the extracted method combined with containsExactly. The destination field is converted to a list, and we assert the list contains the given destinations in the given order. Let's run the test and see if it goes green. It does proving how simple it is to get started with paging. We didn't need to write any special query, only passing the page object with a couple of parameters. Okay, whilst these two concepts have been very much separate so far, what we can do is combine them together so we both page and sort our results at the same time. We can do this by copying and pasting our existing test, renaming it to shouldPageAndSortResults. All we need to do now is pass in our sort object into our page request as an argument. Let's sort by destination descending, which should reverse the order of our elements. We'll pass in 44, 43, 42, 41, and 40 and then run our test to see if it's gone green. It has meaning we can successfully sort both paging and sorting of our queries. Great. So far our tests have been dependent on the provided methods within the paging and sorting repository, but a use of these is actually optional as it's perfectly possible to make these abstractions arguments to the derived queries too, combining all three concepts together into one query. Let's try this out. We can first copy and paste our existing query, this time renaming it to shouldPageAndSortADerivedQuery. We'll then change it so we save 10 flights from Paris and 10 flights from London. Then we'll create a new findByOrigin method, this time passing in London and our page request. It's really nice that Spring Data is capable of this as it further abstracts this from the underlying data store whilst being as feature-rich as possible. All we needed to do was add an extra field to our method. Finally, let's change the parameters to our assertion and then run our test. In this case, it's gone red, and this was done deliberately as it's a common gotcha. It doesn't recognize a page request class and instead needs the pageable interfaces and argument instead, which is what the page request implements. Once we make this change, we can run our test again, and this time it will go green. And that covers it for this demo. By now, we're hopefully building up some knowledge of how powerful Spring Data can be when all of these concepts are combined.

### Swapping Modules
So far, our application architecture looks something like this. Our code is making use of the Repository interface provided by Spring Data Commons in order to interact with the database. We're using Spring Data JPA so this Repository interface wraps JPA data access code. We never see or touch this code directly, instead only working with the repository. We're also using an embedded H2 database, the lifecycle of which is managed by our unit test. Now because we use Spring Data, if we wanted to migrate to a different database, such as MongoDB, a document database, then things wouldn't change so much at all. We will only need to swap string data modules. The Repository interface we're using should then be the same, the same CRUDRepository, paging and sorting abstractions, and even derived query method signatures. So there should be very little refactoring required. Of course, our embedded database will change to an embedded MongoDB, but Spring Boot will help us get started with that quickly too. But what we're really demonstrating here is proof of how data store agnostic Spring Data and the repository pattern are and how useful that makes things. This really powerful concept as previously discussed is what helps Spring Data modules all following the same programming model via Spring Data Commons.

### Demo: Swapping Modules
In this demo, we're going to try switching our project from Spring Data JPA to Spring Data MongoDB as a proof of context of the generic nature of Spring Data Commons. We'll first change the required Maven dependencies, switch our database from H2 to embedded Mongo, remap our entities removing the JPA annotations, leave our repository class untouched, the most important step, and then verify everything still functions by running the tests. Okay, let's start by navigating to our POM file and changing our dependencies. We'll first go from spring-boot-starter-jpa to spring-boot-starter-mongodb. Then we'll remove our H2 dependency as we're no longer working with a relational database, and we'll add a dependency on an embedded MongoDB instead as this is what will now be required as our data store. Thanks to the spring-boot-starter, this will be spun up and torn down automatically during test just like with H2. Once we've done this, our code will no longer compile. However, it's important to note it's only the JPA-specific code that has this problem. Whereas the Spring Data code is fine as we've only worked with shared interfaces in Spring Data Commons. Let's delete the JPA annotations from our Flight entity and change our ID field to a String data type, which MongoDB prefers. That's all we need to do here, but in doing so, our tests no longer compile as they were using a long ID. We can change our ID type parameter to a String in our repository, and really that is it. We've not had to change our repository methods, import any MongoDB- specific repository code, or do anything other than removing JPA and change the type of our ID. Let's run all our tests to verify it still works. They don't pass yet because we still have a data JPA test, which requires Spring Data JPA. All we need to do to fix this is change from DataJpaTest to DataMongoTest, and then we can run our test one final time and see if they pass now. They do, only now we're connecting to a completely different data store with a completely different query language. If we navigate to our CrudTests, we can see that saving, deleting, and finding all work as they did before as they're common operations provided by the CRUDRepository interface in Spring Data Commons. Our derived queries also work, even though MongoDB as a document store, and the queries generated will be in a different query language to before. Also, our paging and sorting repository works too because again these are common abstractions provided by Spring Data Commons regardless of the underlying data store.

### Custom Implementation
Sometimes, but rarely, the Spring Data Repository interface as in derived queries might not be enough for our use case. If this is the case, we can implement a repository method ourselves rather than leaving Spring Data to do it for us. A common gotcha when trying to do this is thinking you can implement the Spring Data Repository method and that Spring Data will use that implementation by default. Without getting into the finer details, this won't work as when Spring generates a repository implementation, it will ignore the existing implementations. To get it to work, we need to generate an additional repository interface, which does not inherit from the Spring Data repository. Any method we put there, we can, of course, implement. We then use composition with our original repository to write our custom method to it. So if we want to implement a method with our own code, we put it in a separate interface, implement that interface, and then make our repository inherit from that interface.

### Demo: Custom Implementation
In our final demo for this module, we're going to create a custom repository interface. We'll then implement the interface with our own custom code, after which we'll make our Spring Data repository extend it. And finally, we'll verify our custom implementation functions with a test. Okay, let's get started by creating a new test called CustomImplTest. We'll run it with the SpringRunner and make it a JPA test just like before, also wiring in our FlightRepository. We'll then create a test named shouldSaveCustomImpl and then save a flight to London whilst creating a helper method in the process. We'll call this flight toDelete and then create a second flight called toKeep, which will be to Paris. Following this, we'll save them, delete the one to London by origin, and assert that the only flight in the database is the one to Paris. Notice how we didn't generate the deleteByOrigin method yet as in this case, we're going to create a custom implementation to perform our query rather than relying on Spring Data to generate it for us. First, let's create a new interface called DeleteByOriginRepository. We'll define our method deleteByOrigin here, navigate to our existing FlightRepository, and make it implement this interface. It's important we do it this way as putting a method on a separate interface allows us to create a custom implementation of it. Let's do this by creating a subclass called DeleteByOriginRepositoryImpl. Now we can literally put any code we want here, even code that wasn't data access code. But for this example, we'll just use the JPA EntityManager to perform the delete query. We'll inject the EntityManager by making it a constructor argument and then create a native delete query, DELETE from flight WHERE origin is equal to our provided parameter. Now that's done, let's switch back to our test and run it to see if it goes green. It does meaning our query has worked. Now we could stop here. But to prove that it really was our code that was executed, let's navigate back to it and add a breakpoint. We can then rerun our test and confirm that the breakpoint was hit, proving that it's indeed our custom code that's getting executed. And that covers it for this demo. This last step hopefully proves that there's no limit to the extensibility of Spring Data, even though in the majority of use cases, the base abstractions are still probably enough.

### Summary
And that covers it for this module. We've learned that in order to query data, each Spring Data module makes use of the Repository interface. This is a data store agnostic interoperable way of executing queries. We will rarely have to write our own implementation code while making use of repositories as Spring Data does a great job of generating all the boilerplate we need. Basic CRUD operations come out of the box through the PagingAndSortingRepository, while the bespoke queries can be derived from Spring Data based on method signatures. And the paging and sorting of queries are abstracted. We can also fall back to creating custom implementations of queries if we need to. In the next module, we'll be using Spring Data with the @Transactional annotation in order to learn how we can manage our database transactions with Spring.

## Working with Transactions

### Spring Transactions
Imagine we had an application that allows a customer to book a ticket for an event. When the customer books a ticket, we will first allocate a seat within the venue to them and also take a payment for the transaction. Once both these things have taken place, then the customer's booking will be completed, and we can send them their ticket. However, if the payment request failed without transactions, we would have a problem. This is because the first step, seat allocation, would still be successful, meaning the seat would be taken up when there's no ticket associated with it. If we wrapped queries in a transaction, then things would be different. This is because a single transaction contains multiple queries, which either all take place or do not take place at all. So if our payment request failed, the whole transaction would fail, rolling back the seat's allocation so there's no longer one allocated in error. We describe a transaction as having asset guarantees, meaning it's atomic so it either all happens or does not happen at all, it's consistent, meaning the data written is valid according to the various constraints, isolated, meaning another transaction cannot see the results of the transaction until it's committed, and it's durable meaning the results of the transaction are written to disk. We won't go into much more detail about this as this course is not for learning the inner workings of a transaction. But what's important to understand here is that the majority of enterprise applications will be dependent on transactions at some point in order to function as they need to. Okay, let's take a look at how we might execute our code in a transaction without Spring. Here's our method, bookTicket, which will allocate the seat and make the payment. Wrapping it in a transaction, first of all, introduces a ton of boilerplate. In this case, the boilerplate is Hibernate. We need to start the transaction, commit the transaction, remember to wrap it in a try-catch block so we can roll the transaction back if there's an exception, and also add a finally block so we always close the session after our transaction completes. Now wouldn't it be great if we could make our bookTicket method transactional without having to write any of that code. Well, with Core Spring we can do this simply by annotating our method with @Transactional. This declarative annotation does all of the boilerplate for us. The exact specifics of how this works by leveraging AOP is beyond the scope of this course. But an oversimplified explanation is that at runtime, Spring will create a proxy, which intercepts calls to @Transactional methods and executes the transaction boilerplate for us eventually calling the real method during this transaction. So you can be confident that declaring something is @Transactional will mean that transaction will be started before the method is called and then committed a row back after the method is called as long as the annotation is on a Spring managed bean. It's also important to note that Spring transaction management technically comes from Core Spring, not from Spring Data. However, as transactions and Spring Data are so heavily used together, it makes logical sense to cover them both in an overview course. So just to be clear about the benefits of transaction management with Spring or Spring Data, the first is that we remove a ton of boilerplate. What was once rings of code is now a simple annotation on a method, which means developers can focus on writing their queries instead of the scaffolding for those queries. It's also declarative and non-invasive. The annotation isn't even part of the code. It's metadata meaning the code will contain only query logic. In turn, this makes bugs a lot less likely because the transaction code is now managed for us by Spring. And the main advantage from the point of view of Spring Data is that it's data-store agnostic. If you're working with a database that supports transactions, the corresponding Spring Data module will know how to generate the corresponding transaction code. If you're working with a non-transactional database, like Cassandra, then this annotation will do nothing.

### Demo: Transactions
In this demo, we'll be creating a transactional method by making use of the @Transactional annotation. We'll then verify that the method works by stepping through the code and also triggering transaction rollback. Okay, let's get started by creating a new test. We'll call it TransactionalTests. Just like in the previous module, we'll run it with the SpringRunner, but this time make it a Spring Boot test as we'll be creating some extra non-JPA related beans. We can then wire in our FlightRepository and then create a new setUp method, which deletes everything from our table at the start of the test. Now let's create a test called shouldNotRollBackWhenTheresNoTransaction. The goal of this test will be to compare it against a transactional test to prove that with transactions, we are able to roll back in the event of an exception. Okay, let's create a package called Service and create a class called FlightsService. In our new class, we'll create a method, which saves a flight and then throws an exception. In a real application, in between, we might have some extra code that would do some more reads and writes to the database. Let's switch back to our test and wire in our FlightsService and then call our saveFlight method. As is an exception thrown, we can then surround the call with a try-catch block and then in the finally block, assert that a FlightRepository is not empty. It's pretty obvious this should be the case as we throw our exception after saving the flight. Let's run our test and verify it. Yes, it has gone green. Now we can move on to a more interesting test, which makes use of the @Transactional annotation. Let's copy and paste our existing one and rename it shouldNotRollBackWhenThereIsATransaction. Then let's change our assertion to check that our flights are empty. We'll then call a new method, saveFlightTransactional instead. It will be exactly the same as before, only annotated with @Transactional. What this means is on invoking the method, the transaction will start and then will be committed once the method completes successfully. As we throw an exception rather than allowing the method to complete, our transaction should never be successfully committed so the flight will not end up in the database. Okay, let's switch back to our test, run it, and confirm that the flight was not saved. Great, it wasn't, meaning that Spring successfully executed our code within a transaction when all we needed to do was use the @Transactional annotation. This proves how much easier things can be when we use Spring to reduce our boilerplate.

### Summary
And that covers it for this module. We've learned about how common it is to want to be able to use transactions with Spring Data as we often need ACID guarantees on performing a series of related queries as part of a business operation. Transactions introduce a lot of boilerplate to our code base, making our code verbose and slowing down the time it takes for us to write a feature. Spring provides the @Transactional annotation, a declarative alternative, which lets us achieve transactions without this boilerplate.